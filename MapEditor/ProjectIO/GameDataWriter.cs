using GameEditor.GameData;
using GameEditor.MapEditor;
using GameEditor.SpriteEditor;
using GameEditor.TilesetEditor;
using System;
using System.Collections.Generic;
using System.Data.Common;
using System.Dynamic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml.Linq;

namespace GameEditor.ProjectIO
{
    public class GameDataWriter : IDisposable
    {
        const string PREFIX_GAME_TILESET_DATA = "game_tileset_data";
        const string PREFIX_GAME_SPRITE_DATA = "game_sprite_data";
        const string PREFIX_GAME_MAP_TILES = "game_map_tiles";
        const string PREFIX_GAME_MAP_SPRITE_ANIMATION = "GAME_SPRITE_ANIMATION";

        private bool disposed;
        protected IdentifierNamespace identifiers = new IdentifierNamespace();
        protected StreamWriter f;
        protected uint syncBits;
        protected int dataSize;

        public GameDataWriter(string filename, byte vgaSyncBits) {
            f = new StreamWriter(filename, false, Encoding.UTF8);
            f.NewLine = "\n";
            syncBits = ((uint) vgaSyncBits) & 0xc0;
            Util.Log($"-> got sync bits {syncBits} from {vgaSyncBits}");
        }

        public void Dispose() {
            if (disposed) return;
            f.Dispose();
            GC.SuppressFinalize(this);
            disposed = true;
        }

        protected void BeginWrite() {
            dataSize = 0;
            f.WriteLine($"// Auto-generated by GameEditor at {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")}");
            f.WriteLine();
            f.WriteLine("#include \"game_data.h\"");
            f.WriteLine();
            f.WriteLine($"#define GAME_DATA_VGA_SYNC_BITS 0x{syncBits:x02}");
            f.WriteLine();
        }

        protected void EndWrite() {
            f.WriteLine($"// total data size: {dataSize} bytes");
            f.Close();
        }

        protected byte EncodeColor(byte red, byte green, byte blue) {
            uint r = ((uint) red   >> 6) & 0x3;
            uint g = ((uint) green >> 6) & 0x3;
            uint b = ((uint) blue  >> 6) & 0x3;
            return (byte) (syncBits | (b<<4) | (g<<2) | r);
        }

        // =============================================================
        // === TILESETS
        // =============================================================

        protected void WriteTilesetData(Tileset tileset) {
            string ident = identifiers.Add(tileset, PREFIX_GAME_TILESET_DATA, tileset.Name);
            f.Write($"static const uint32_t {ident}[] = ");
            f.WriteLine("{");

            const int tileSize = Tileset.TILE_SIZE;
            const int numBlocksPerTile = tileSize * tileSize / 4;

            byte[] bmp = new byte[4 * tileSize * tileSize];
            for (int tile = 0; tile < tileset.NumTiles; tile++) {
                tileset.ReadTilePixels(tile, bmp);
                f.Write($"  // tile {tile}");
                for (int bl = 0; bl < numBlocksPerTile; bl++) {
                    if (bl % 8 == 0) {
                        f.WriteLine();
                        f.Write("  ");
                    }
                    uint block = 0;
                    for (int p = 0; p < 4; p++) {
                        byte b = bmp[bl*16 + p*4 + 0];
                        byte g = bmp[bl*16 + p*4 + 1];
                        byte r = bmp[bl*16 + p*4 + 2];
                        block |= ((uint) EncodeColor(r, g, b)) << (p*8);
                    }
                    f.Write("0x{0:x08},", block);
                }
                f.WriteLine();
                dataSize += bmp.Length;
            }

            f.WriteLine("};");
            f.WriteLine();
        }

        protected void WriteTilesets() {
            f.WriteLine("// ================================================================");
            f.WriteLine("// === TILESETS");
            f.WriteLine("// ================================================================");
            f.WriteLine();
            foreach (TilesetItem ti in EditorState.TilesetList) {
                WriteTilesetData(ti.Tileset);
            }
            f.WriteLine("const struct GAME_IMAGE game_tilesets[] = {");
            const int size = Tileset.TILE_SIZE;
            foreach (TilesetItem ti in EditorState.TilesetList) {
                string ident = identifiers.Get(ti.Tileset);
                f.WriteLine($"  {{ {size}, {size}, {size/4}, {ti.Tileset.NumTiles}, {ident} }},");
                dataSize += 5 * 4;  // 4 * int32_t + 1*intptr_t
            }
            f.WriteLine("};");
            f.WriteLine();
        }

        // =============================================================
        // === SPRITES
        // =============================================================

        protected void WriteSpriteData(Sprite sprite) {
            string ident = identifiers.Add(sprite, PREFIX_GAME_SPRITE_DATA, sprite.Name);
            f.Write($"static const uint32_t {ident}[] = ");
            f.WriteLine("{");

            int numBlocksPerLine = (sprite.Width+3) / 4;

            byte[] bmp = new byte[4 * sprite.Width * sprite.Height];
            for (int frame = 0; frame < sprite.NumFrames; frame++) {
                sprite.ReadFramePixels(frame, bmp);
                f.Write($"  // frame {frame}");
                for (int y = 0; y < sprite.Height; y++) {
                    for (int bl = 0; bl < numBlocksPerLine; bl++) {
                        if (bl % 8 == 0) {
                            f.WriteLine();
                            f.Write("  ");
                        }
                        int numPixelsInBlock = 4 - int.Clamp(4*(bl+1)-sprite.Width, 0, 3);
                        uint block = 0;
                        for (int p = 0; p < numPixelsInBlock; p++) {
                            byte b = bmp[y*sprite.Width*4 + bl*16 + p*4 + 0];
                            byte g = bmp[y*sprite.Width*4 + bl*16 + p*4 + 1];
                            byte r = bmp[y*sprite.Width*4 + bl*16 + p*4 + 2];
                            block |= ((uint) EncodeColor(r, g, b)) << (p*8);
                        }
                        f.Write("0x{0:x08},", block);
                    }
                }
                f.WriteLine();
                dataSize += 4*numBlocksPerLine * sprite.Height;
            }

            f.WriteLine("};");
            f.WriteLine();
        }

        protected void WriteSprites() {
            f.WriteLine("// ================================================================");
            f.WriteLine("// === SPRITES");
            f.WriteLine("// ================================================================");
            f.WriteLine();
            foreach (SpriteItem si in EditorState.SpriteList) {
                WriteSpriteData(si.Sprite);
            }
            f.WriteLine("const struct GAME_IMAGE game_sprites[] = {");
            foreach (SpriteItem si in EditorState.SpriteList) {
                int w = si.Sprite.Width;
                int h = si.Sprite.Height;
                int nFrames = si.Sprite.NumFrames;
                string ident = identifiers.Get(si.Sprite);
                f.WriteLine($"  {{ {w}, {h}, {(w+3)/4}, {nFrames}, {ident} }},");
                dataSize += 5 * 4 + 4*16;  // 4 * int32_t + 1*intptr_t
            }
            f.WriteLine("};");
            f.WriteLine();
        }

        // =============================================================
        // === MAPS
        // =============================================================

        protected void WriteMapTiles(MapData map) {
            string ident = identifiers.Add(map, PREFIX_GAME_MAP_TILES, map.Name);
            MapTiles tiles = map.Tiles;
            f.Write($"static const uint8_t {ident}[] = ");
            f.WriteLine("{");
            f.Write("  // background");
            for (int y = 0; y < tiles.Height; y++) {
                for (int x = 0; x < tiles.Width; x++) {
                    if ((y*tiles.Width + x) % 16 == 0) { f.WriteLine(); f.Write("  "); }
                    f.Write($"0x{tiles.bg[x,y]&0xff:x02},");
                }
            }
            f.WriteLine();
            f.Write("  // foreground");
            for (int y = 0; y < tiles.Height; y++) {
                for (int x = 0; x < tiles.Width; x++) {
                    if ((y*tiles.Width + x) % 16 == 0) { f.WriteLine(); f.Write("  "); }
                    f.Write($"0x{tiles.fg[x,y]&0xff:x02},");
                }
            }
            f.WriteLine();
            f.Write("  // collision");
            for (int y = 0; y < tiles.Height; y++) {
                for (int x = 0; x < tiles.Width; x++) {
                    if ((y*tiles.Width + x) % 16 == 0) { f.WriteLine(); f.Write("  "); }
                    f.Write($"0x{tiles.clip[x,y]&0xff:x02},");
                }
            }
            f.WriteLine();
            f.WriteLine("};");
            f.WriteLine();
            dataSize += 3 * tiles.Width * tiles.Height;
        }
        protected void WriteMaps() {
            f.WriteLine("// ================================================================");
            f.WriteLine("// === MAPS");
            f.WriteLine("// ================================================================");
            f.WriteLine();
            foreach (MapDataItem mi in EditorState.MapList) {
                WriteMapTiles(mi.Map);
            }

            Dictionary<Tileset, int>? tsIndices = new Dictionary<Tileset, int>();
            foreach (var (ti, index) in EditorState.TilesetList.Zip(Enumerable.Range(0, EditorState.TilesetList.Count))) {
                tsIndices[ti.Tileset] = index;
            }

            f.WriteLine("const struct GAME_MAP game_maps[] = {");
            foreach (MapDataItem mi in EditorState.MapList) {
                string tiles = identifiers.Get(mi.Map);
                string tileset = $"game_tilesets[{EditorState.GetTilesetIndex(mi.Map.Tileset)}]";
                f.WriteLine($"  {{ {mi.Map.Tiles.Width}, {mi.Map.Tiles.Height}, {tileset}, {tiles} }},");
            }
            f.WriteLine("};");
            f.WriteLine();
            dataSize += 2*2 + 2*4;  // 2*int16_t + 2*intptr_t
        }

        // =============================================================
        // === SPRITE ANIMATIONS
        // =============================================================

        protected void WriteSpriteAnimations() {
            f.WriteLine("// ================================================================");
            f.WriteLine("// === SPRITE ANIMATIONS");
            f.WriteLine("// ================================================================");
            f.WriteLine();

            f.WriteLine("enum GAME_SPRITE_ANIMATION {");
            foreach (SpriteAnimationItem ai in EditorState.SpriteAnimationList) {
                string ident = identifiers.Add(ai.Animation, PREFIX_GAME_MAP_SPRITE_ANIMATION,
                                               ai.Animation.Name, IdentifierNamespace.UPPER_CASE);
                f.WriteLine($"  {ident},");
            }
            f.WriteLine("};");

            Dictionary<Sprite, int>? sprIndices = new Dictionary<Sprite, int>();
            foreach (var (si, index) in EditorState.SpriteList.Zip(Enumerable.Range(0, EditorState.SpriteList.Count))) {
                sprIndices[si.Sprite] = index;
            }

            f.WriteLine("const struct GAME_SPRITE_ANIMATION game_sprite_animations[] = {");
            foreach (SpriteAnimationItem ai in EditorState.SpriteAnimationList) {
                string animName = identifiers.Get(ai.Animation);
                string sprite = $"game_sprites[{EditorState.GetSpriteIndex(ai.Animation.Sprite)}]";
                f.WriteLine($"  {{  // {animName}");
                f.WriteLine($"    {sprite},");
                f.WriteLine($"    {ai.Animation.NumLoops-1},");
                f.WriteLine("    {");
                foreach (SpriteAnimationLoop loop in ai.Animation.GetAllLoops()) {
                    if (loop.IsImmutable) continue;  // skip "all frames" loop
                    f.Write($"      {{ {loop.NumFrames}, {{ ");
                    for (int i = 0; i < loop.NumFrames; i++) {
                        f.Write($"{loop.Frame(i)},");
                    }
                    f.WriteLine(" } },");
                }
                f.WriteLine("    },");
                f.WriteLine("  },");
            }
            f.WriteLine("};");
            f.WriteLine();
            dataSize += 2*2 + 2*4;  // 2*int16_t + 2*intptr_t
        }

        // =============================================================
        // === PROJECT
        // =============================================================

        public void WriteProject() {
            BeginWrite();
            WriteTilesets();
            WriteSprites();
            WriteMaps();
            WriteSpriteAnimations();
            EndWrite();
        }
    }
}
